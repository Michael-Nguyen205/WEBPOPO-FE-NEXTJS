import type { Metadata } from "next";
import localFont from "next/font/local";
import "../../globals.css";
import Footer from "./components/footer";
import { headers } from "next/headers";
import { getPathname } from "@/i18n/routing";
import { getTranslations } from "next-intl/server";

import { NextIntlClientProvider } from "next-intl";
import { getMessages } from "next-intl/server";
import "animate.css";
import { ToggleMenuProvider } from "@/shared/context/toggleMenuProvider";
import { routing } from "@/i18n/routing";
import Header from "@/app/[locale]/(publics)/components/header/Header";

import { fetchData } from "@/shared/utils/CallApiUtil";
// import { ErrorBoundary } from 'react-error-boundary'
import GlobalError from "@/app/global-error";
import ErrorBoundary from "@/shared/components/ErrorBoundary";
import { usePathname } from "@/i18n/routing";
//  Lấy dữ liệu từ API


// Font configuration
const mylocalfont = localFont({
  src: "../../../../public/fonts/Exo_2/Exo2-VariableFont_wght.ttf",
  display: "swap",
  weight: "400",
});







// // Metadata definition
// export const metadata: Metadata = {
//   title: "Create Next App",
//   description: "Generated by create next app",
// };


// app/[locale]/
export async function generateMetadata({
  params: { locale },
}: {
  params: { locale: string };
}): Promise<Metadata> {
  const header = headers();

  const host = header.get("host") || "";
  const href = header.get("x-current-path")?.toString() || "";

  // Generate the current pathname
  const pathname = getPathname({ locale, href });

  // Fetch translations for metadata
  const t = await getTranslations({ locale, namespace: "HomePage.Metadata" });

  // Canonical URL (default locale)
  const canonicalUrl = `${host}${getPathname({
    locale: routing.defaultLocale,
    href,
  })}`;

  // Generate alternate links for all supported locales
  const alternates = routing.locales.map((loc) => ({
    hreflang: loc,
    href: `${host}${getPathname({ locale: loc, href })}`,
  }));

  return {
    title: t("title"), // Translated title
    description: t("description"), // Translated description
    keywords: t("keywords"),
    authors: [{ name: t("author") }],
    alternates: {
      canonical: canonicalUrl, // Canonical URL
      languages: Object.fromEntries(
        alternates.map(({ hreflang, href }) => [hreflang, href])
      ),
    },

    openGraph: {
      type: "website",
      url: `${host}${pathname}`,
      title: t("og.title"),
      description: t("og.description"),
      images: [
        {
          url: `${host}/images/og-image.jpg`,
          width: 1200,
          height: 630,
          alt: "OpenGraph Image Alt Text",
        },
        {
          url: `${host}/images/og-image-secondary.jpg`,
          width: 800,
          height: 600,
          alt: "Secondary OpenGraph Image",
        },
      ],
    },
    
  };
}

type Href = Parameters<typeof getPathname>[0]["href"];

// Helper function to generate complete URLs for a specific locale
function getUrl(href: Href, locale: (typeof routing.locales)[number]): string {
  const pathname = getPathname({ locale, href });
  return `${pathname}`;
}













// Generate static params function
export function generateStaticParams() {
  return routing.locales.map((locale) => ({ locale }));
}

// RootLayout component nhận categories từ props
export default async function RootLayout({
  children,
  params: { locale },
  categories, // Nhận categories từ props
}: Readonly<{
  children: React.ReactNode;
  params: { locale: string };
  categories: {
    id: string;
    name: string;
    children?: { id: string; name: string }[];
  }[]; // Đảm bảo rằng categories có kiểu dữ liệu hợp lý
}>) {
  // Lấy các tin nhắn cho locale hiện tại
  const messages = await getMessages({ locale });
  console.log("Current Pathname:", usePathname);
  // const pathname = usePathname();
  // console.log("Current Pathname:", pathname);

  // Log categories để kiểm tra
  console.log("categories", categories);

  return (
    <html lang={locale}>
      <body className={`${mylocalfont.className}`}>
        <div className="">
          <NextIntlClientProvider messages={messages}>
            <ToggleMenuProvider>
              <ErrorBoundary fallback={<GlobalError />}>
                <Header />

                {children}
                <Footer />
              </ErrorBoundary>
            </ToggleMenuProvider>
          </NextIntlClientProvider>
        </div>
      </body>
    </html>
  );
}
